(declare (usual-integrations))
(define old-values values)
(define (values . objects)
  (if (= (length objects) 1)
      (car objects)
      (apply old-values objects)))
(define-syntax import
  (syntax-rules ()
    ((import stuff ...)
     (begin) ;; do nothing
     )))
(define string->utf8 identity-procedure)
(define utf8->string identity-procedure)
(define (make-bytevector k #!optional byte)
  (make-vector-8b k (if (default-object? byte) 0 byte)))
(define (bytevector-u8-set! bytevector k byte)
  (vector-8b-set! bytevector k byte))

(define call/cc call-with-current-continuation)
(define flush-output-port
  flush-output)
(define (current-second)
  (- (get-universal-time) epoch))
(define (current-jiffy)
  (real-time-clock))
(define (jiffies-per-second)
  (/ 1 (internal-time/ticks->seconds 1)))

(define (this-scheme-implementation-name) (string-append "mit-" (get-subsystem-version-string "Release")))


#|
(define (open-input-bytevector bytevector)
  (open-input-string (vector->string (vector-map integer->char (%bytevector-data bytevector)))))
(define (open-output-bytevector)
  (open-output-string))
(define (get-output-bytevector port)
  (make-%bytevector (vector-map char->integer (string->vector (get-output-string port)))))
(define (read-u8 #!optional port)
  (char->integer (read-char (if port port (current-input-port)))))
(define (peek-u8 #!optional port)
  (char->integer (peek-char (if port port (current-input-port)))))
(define (u8-ready? #!optional port)
  (char-ready? (if port port (current-input-port))))
(define (read-bytevector k #!optional port)
  (let ((s (make-string k)))
    (let ((n (read-string! s (if (default-object? port) (current-input-port) port))))
      (if (or (eof-object? n)
              (zero? n))
          (eof-object)
          (make-%bytevector (vector-map char->integer (string->vector (substring s 0 n))))))))
(define (write-u8 byte #!optional port)
  (write-char (integer->char byte) (if port port (current-output-port))))
(define (write-bytevector bytevector #!optional port start end)
  (let ((port (if (default-object? port) (current-output-port) port))
        (start (if (default-object? start) 0 start))
        (end (if (default-object? end) (bytevector-length bytevector) end)))
    (vector-for-each (lambda (el)
                       (write-u8 el port))
                     (vector-copy (%bytevector-data bytevector) start end))))

(define bytevector?
  %bytevector?)
(define (make-bytevector k #!optional byte)
  (make-%bytevector (make-vector k (if (default-object? byte) 0 byte))))
(define (bytevector . byte)
  (make-%bytevector (apply vector byte)))
(define (bytevector-length bytevector)
  (vector-length (%bytevector-data bytevector)))
(define (bytevector-u8-ref bytevector k)
  (vector-ref (%bytevector-data bytevector) k))
(define (bytevector-u8-set! bytevector k byte)
  (vector-set! (%bytevector-data bytevector) k byte))
(define (bytevector-copy bytevector #!optional start end)
  (let* ((start (if (default-object? start) 0 start))
         (end (if (default-object? end) (bytevector-length from) end))
         (len (- end start))
         (result (make-bytevector len)))
    (bytevector-copy! result 0 bytevector start end)
    result))
(define (bytevector-copy! to at from #!optional start end)
  ;; from chibi
  (let* ((start (if (default-object? start) 0 start))
         (end (if (default-object? end) (bytevector-length from) end))
         (limit (min end (+ start (- (bytevector-length to) at)))))
    (if (<= at start)
        (do ((i at (+ i 1)) (j start (+ j 1)))
            ((>= j limit))
          (bytevector-u8-set! to i (bytevector-u8-ref from j)))
        (do ((i (+ at (- end start 1)) (- i 1)) (j (- limit 1) (- j 1)))
            ((< j start))
          (bytevector-u8-set! to i (bytevector-u8-ref from j))))))

(define (bytevector-append . vecs)
  ;; from chibi
  (let* ((len (apply + (map bytevector-length vecs)))
         (res (make-bytevector len)))
    (let lp ((ls vecs) (i 0))
      (if (null? ls)
          res
          (let ((v-len (bytevector-length (car ls))))
            (bytevector-copy! res i (car ls))
            (lp (cdr ls) (+ i v-len)))))))
(define (utf8->string bytevector #!optional start end)
  (let ((start (if (default-object? start) 0 start))
        (end (if (default-object? end) (bytevector-length bytevector) end)))
    (vector->string (vector-map integer->char (%bytevector-data (bytevector-copy bytevector start end))))))
(define (string->utf8 string #!optional start end)
  (let ((start (if (default-object? start) 0 start))
        (end (if (default-object? end) (string-length string) end)))
    (make-%bytevector (vector-map char->integer (string->vector (substring string start end))))))
|#
