(module test)
(define current-second
  current-seconds)
(define (jiffies-per-second) 1000000000)
(define (current-jiffy)
  (llong->flonum (current-nanoseconds)))
(define (this-scheme-implementation-name)
  (string-append "bigloo-" (bigloo-config 'release-number)))
(define inexact exact->inexact)
(define exact inexact->exact)
(define call-with-current-continuation call/cc)
(define (error . args) args)
(define (exact-integer? v)
  (and (integer? v) (exact? v)))
(define (square x)
  (* x x))
(define (make-bytevector n) (make-u8vector n))
(define (bytevector-u8-set! vec i x)
  (u8vector-set! vec i (if (integer? x) (fixnum->uint8 x) x)))
(define (string->utf8 s)
  (let* ((n (string-length s))
         (v (make-u8vector n)))
    (let iter ((pos 0))
      (when (< pos n)
        (u8vector-set! v pos (fixnum->uint8 (char->integer (string-ref s pos))))
        (iter (+ pos 1))))
    v))
(define (utf8->string v)
  (let* ((l (u8vector->list v))
         (s (make-string (u8vector-length v)))
         (pos 0))
    (for-each (lambda (code)
                (string-set! s pos (integer->char (uint8->fixnum code)))
                (set! pos (+ pos 1)))
              l)
    s))
(define (integer-length n)
  (inexact->exact (ceiling (/ (log n)
                              (log 2)))))
;; taken from mit-scheme, src/runtime/primitive-arithmetic.scm
(define (exact-integer-sqrt n)
  (if (= 0 n)
      (values 0 0)
      (let loop
	  ((i
	    (expt 2
		  (let ((n-bits (integer-length n)))
		    (if (= 0 (remainder n-bits 2))
			(quotient n-bits 2)
			(+ (quotient n-bits 2) 1))))))
	(let ((j (quotient (+ i (quotient n i)) 2)))
	  (if (>= j i)
	      (values i (- n (* i i)))
	      (loop j))))))
#;
